# 11. 오버라이딩과 추상화
 ## 오버라이딩 : 이미 구현되어 있는 함수의 기능을 자식 클래스에서 변경해야 할 때 
 ## 추상화 : 형식만 선언하고 실제 구현은 자식클래스에 위임
fun main() {
    var r = Rabbit()
    
    r.eat()
    r.sniff()
}

abstract class Animal {
    abstract fun eat()
    fun sniff() {
        println("킁킁")
    }
}

class Rabbit : Animal() {
    override fun eat() {
        println("당근을 먹습니다")
    }
}
- 인터페이스 : 구현부가 있는 함수(open함수), 구현부가 없는 함수(abstract함수), 서로 다른 기능들을 여러 개 물려주어야 할 때 사용

# 12. 기본 프로젝트 구조
 ## 프로젝트, 모듈, 폴더, 파일은 실제 파일 시스템에 기반한 물리적인 구조 담당
 ## 패키지는 논리적인 구조 담당
 ## 클래스명과 파일명은 일치하지 않아도 되고, 하나의 파일에 여러개의 클래스를 넣어도 알아서 컴파일이 가능하다.
 ## 'import 외부패키지'로 외부패키지의 함수,클래스를 가져다 사용할 수 있다.


# 13. 변수, 함수, 클래스의 접근범위의 접근제한자
 ## 스코프 : 변수나 함수, 클래스 같은 멤버들을 서로 공유하여 사용할 수 있는 범위를 지정해 둔 단위(패키지)
  ### 스코프 외부 : 스코프 내부의 멤버를 참조연산자로만 참조가 가능하다.
  ### 동일 스코프 내부 : 멤버들을 공유할 수 있다.
  ### 하위 스코프 : 상위 스코프의 멤버를 재정의 할 수 있다.
 ## 접근제한자 : 스코프 외부에서 스코프 내부에 접근할 때 그 권한을 개발자가 제어할 수 있는 기능
  ### 패키지 스코프 : public(기본값), 어떤 패키지에서도 접근 가능 / internal, 같은 모듈 내에서만 접근 가능 / private, 같은 파일 내에서만 접근 가능
  ### 클래스 스코프 : public(기본값), 클래스 외부에서 늘 접근 가능 / private, 클래스 내부에서만 접근 가능 / protected, 클래스 자신과 상속받은 클래스에서 접근 가능

# 14. 고차함수와 람다함수
 ## 고차함수 : 함수를 마치 클래스에서 만들어 낸 인스턴스처럼 취급하는 방법, 코틀린의 모든 함수 가능
 ## 람다함수 : 자체로 고차함수, 별도의 연산자 없이도 변수에 담을 수 있다.
    fun main() {
        b(::a) // 일반 함수를 고차 함수로 변경해 주는 연산자
        
        val c: (String)->Unit = {str -> println("$str 람다함수")}
        b(c)
    }

    fun a(str: String) {
        println("$str 함수 a")
    }

    fun b (function: (String)->Unit) {
        function("b가 호출한")
}
